diff -r d3612c7f9d7b geom/lib/libgeom.h
--- a/geom/lib/libgeom.h	Tue Apr 12 01:30:53 2016 +0200
+++ b/geom/lib/libgeom.h	Mon Apr 18 19:40:38 2016 +0200
@@ -90,6 +90,9 @@
 9 = MULTILINESTRING
 10 = MULTISURFACE
 11 = MULTIPOLYGON
+15 = POLYEHDRALSURFACE
+16 = TIN / TRIANGULATEDSURFACE
+17 = TRIANGLE
 
 */
 
@@ -102,7 +105,10 @@
 	wkbMultiPoint_mdb = 5,
 	wkbMultiLineString_mdb = 6,
 	wkbMultiPolygon_mdb = 7,
-	wkbGeometryCollection_mdb = 8
+	wkbGeometryCollection_mdb = 8,
+	wkbPolyehdralSurface_mdb = 15,
+	wkbTin_mdb = 16, //TriangulatedSurface
+	wkbTriangle_mdb = 17
 } wkb_type;
 
 libgeom_export const char *geom_type2str(int t, int flag);
diff -r d3612c7f9d7b geom/monetdb5/Makefile.ag
--- a/geom/monetdb5/Makefile.ag	Tue Apr 12 01:30:53 2016 +0200
+++ b/geom/monetdb5/Makefile.ag	Mon Apr 18 19:40:38 2016 +0200
@@ -16,7 +16,7 @@
 lib__geom = {
 	MODULE
 	DIR = libdir/monetdb5
-	SOURCES = geom.h geom.c geomBulk.c geom_upgrade.c
+	SOURCES = geom.h geom.c geomBulk.c geom_upgrade.c geom_geojson.c geom_x3d.c
 	LIBS = ../lib/libgeom \
 		   ../../gdk/libbat \
 	       ../../common/stream/libstream \
diff -r d3612c7f9d7b geom/monetdb5/geom.c
--- a/geom/monetdb5/geom.c	Tue Apr 12 01:30:53 2016 +0200
+++ b/geom/monetdb5/geom.c	Mon Apr 18 19:40:38 2016 +0200
@@ -1801,6 +1801,53 @@
 	return MAL_SUCCEED;
 }
 
+str wkbPolygonize(wkb** outWKB, wkb** geom){
+	GEOSGeom geosGeometry = wkb2geos(*geom);
+	int i = 0, geometriesNum = GEOSGetNumGeometries(geosGeometry);
+	GEOSGeometry* outGeometry;
+	const GEOSGeometry **multiGeometry;
+
+	multiGeometry = malloc(sizeof(GEOSGeometry*) * geometriesNum);
+	for(i=0; i<geometriesNum; i++) {
+		multiGeometry[i] = GEOSGetGeometryN(geosGeometry, i);
+	}
+
+	if(!(outGeometry = GEOSPolygonize(multiGeometry, geometriesNum))) {
+		*outWKB = NULL;
+		for (i = 0; i < geometriesNum; i++) {
+			GEOSGeom_destroy((GEOSGeometry *)multiGeometry[i]);
+		}
+		return createException(MAL, "geom.Polygonize", "GEOSPolygonize failed");
+	}
+
+	for (i = 0; i < geometriesNum; i++) {
+		GEOSGeom_destroy((GEOSGeometry *)multiGeometry[i]);
+	}
+
+	*outWKB = geos2wkb(outGeometry);
+	GEOSGeom_destroy(outGeometry);
+
+	return MAL_SUCCEED;
+}
+
+str wkbSimplifyPreserveTopology(wkb** outWKB, wkb** geom, float* tolerance){
+	GEOSGeom geosGeometry = wkb2geos(*geom);
+	GEOSGeometry* outGeometry;
+
+	if(!(outGeometry = GEOSTopologyPreserveSimplify(geosGeometry, *tolerance))) {
+		*outWKB = NULL;
+		GEOSGeom_destroy(geosGeometry);
+		return createException(MAL, "geom.SimplifyPreserveTopology", "GEOSSimplifyPreserveTopology failed");
+	}
+
+	GEOSGeom_destroy(geosGeometry);
+
+	*outWKB = geos2wkb(outGeometry);
+	GEOSGeom_destroy(outGeometry);
+
+	return MAL_SUCCEED;
+}
+
 str geom_2_geom(wkb** resWKB, wkb **valueWKB, int* columnType, int* columnSRID) {
 	GEOSGeom geosGeometry;
 	int geoCoordinatesNum = 2;
@@ -4347,6 +4394,57 @@
 	return MAL_SUCCEED;
 }
 
+#if 0
+str wkbBox3D(mbr** box, wkb** point1, wkb** point2) {
+    GEOSGeom point1_geom, point2_geom;
+    double xmin=0.0, ymin=0.0, zmin=0.0, xmax=0.0, ymax=0.0, zmax=0.0;
+
+    if(wkb_isnil(*point1) || wkb_isnil(*point2)) {
+        *box=mbr_nil;
+        return MAL_SUCCEED;
+    }
+
+    point1_geom = wkb2geos(*point1);
+    if((GEOSGeomTypeId(point1_geom)+1) != wkbPoint_mdb) {
+        GEOSGeom_destroy(point1_geom);
+        *box = mbr_nil;
+        throw(MAL, "geom.MakeBox3D", "Geometries should be points");
+    }
+
+    point2_geom = wkb2geos(*point2);
+    if((GEOSGeomTypeId(point2_geom)+1) != wkbPoint_mdb) {
+        GEOSGeom_destroy(point1_geom);
+        GEOSGeom_destroy(point2_geom);
+        *box = mbr_nil;
+        throw(MAL, "geom.MakeBox3D", "Geometries should be points");
+    }
+
+    if(GEOSGeomGetX(point1_geom, &xmin) == -1 ||
+       GEOSGeomGetY(point1_geom, &ymin) == -1 ||
+       GEOSGeomGetY(point1_geom, &zmin) == -1 ||
+       GEOSGeomGetX(point2_geom, &xmax) == -1 ||
+       GEOSGeomGetY(point2_geom, &ymax) == -1 ||
+       GEOSGeomGetY(point2_geom, &zmax) == -1) {
+
+        GEOSGeom_destroy(point1_geom);
+        GEOSGeom_destroy(point2_geom);
+        *box = mbr_nil;
+        throw(MAL, "geom.MakeBox3D", "Error in reading the points' coordinates");
+
+    }
+
+    *box = (mbr*) GDKmalloc(sizeof(mbr));
+    (*box)->xmin = (float) (xmin < xmax ? xmin : xmax);
+    (*box)->ymin = (float) (ymin < ymax ? ymin : ymax);
+    (*box)->zmin = (float) (zmin < zmax ? zmin : zmax);
+    (*box)->xmax = (float) (xmax > xmin ? xmax : xmin);
+    (*box)->ymax = (float) (ymax > ymin ? ymax : ymin);
+    (*box)->zmax = (float) (zmax > zmin ? zmax : zmin);
+
+    return MAL_SUCCEED;
+}
+#endif
+
 /*returns true if the two
  * 	mbrs overlap */
 str mbrOverlaps(bit *out, mbr **b1, mbr **b2) {
@@ -5689,3 +5787,84 @@
 	*out = TRUE;
 	return MAL_SUCCEED;
 }
+
+/* Exported from PostGIS */
+str
+wkbAsX3D(str *res, wkb **geomWKB, int *maxDecDigits, int *option)
+{
+    static const char* default_defid = "x3d:"; /* default defid */
+    const char* defid = default_defid;
+	GEOSGeom geom = wkb2geos(*geomWKB);
+    int srid = (*geomWKB)->srid;
+
+    if (*option & GEOM_X3D_USE_GEOCOORDS) {
+        if (srid != 4326) {
+		    throw(MAL, "geom.wkbAsX3D", "Only SRID 4326 is supported for geocoordinates.");
+        }
+    }
+
+	if ( (*res = geom_to_x3d_3(geom, *maxDecDigits, *option, defid)) == NULL )
+		throw(MAL, "geom.wkbAsX3D", "Failed, XML returned is NULL!!!");
+	return MAL_SUCCEED;
+}
+
+str
+wkbAsGeoJson(str *res, wkb **geomWBK, int *maxDecDigits, int *option)
+{
+	GEOSGeom geom = wkb2geos(*geomWBK);
+    int has_bbox = 0;
+	char *srs = NULL;
+    int precision = DBL_DIG;
+    int srid = (*geomWBK)->srid;
+
+    if ( *maxDecDigits > DBL_DIG )
+        precision = DBL_DIG;
+    else if ( *maxDecDigits < 0 )
+        precision = 0;
+
+    if (*option) {
+        if (*option & 1)  
+            has_bbox = 1; 
+    }
+
+    if ( srid != 0 ) 
+    { 
+        if ( *option & 2 ) {
+			char* sridTxt = "SRID:";
+			char* sridIntToString = NULL;
+			size_t len2 = 0;
+			int digitsNum = 10; //MAX_INT = 2,147,483,647
+
+
+			//count the number of digits in srid
+			if(srid < 0)
+				throw(MAL, "geom.wkbAsGeoJson", "Negative SRID");
+
+			sridIntToString = GDKmalloc(digitsNum+1);
+			if(sridIntToString == NULL) {
+				throw(MAL, "geom.wkbAsGeoJson", MAL_MALLOC_FAIL);
+			}
+			digitsNum = sprintf(sridIntToString, "%d", srid);
+
+			len2 = strlen(sridIntToString)+strlen(sridTxt)+2;
+			srs = GDKmalloc(len2);
+			if(srs == NULL) {
+				GDKfree(sridIntToString);
+				throw(MAL, "geom.wkbAsGeoJson", MAL_MALLOC_FAIL);
+			}
+
+			memcpy(srs, sridTxt, strlen(sridTxt));
+			memcpy(srs+strlen(sridTxt), sridIntToString, strlen(sridIntToString));
+			(srs)[strlen(sridTxt)+strlen(sridIntToString)] = ';';
+			(srs)[len2-1] = '\0';
+
+			GDKfree(sridIntToString);
+        }
+        if ( *option & 4 ) 
+		    throw(MAL, "geom.wkbAsGeoJson", "Failed, SRID long version not supported!!!");
+    }
+
+	if ( (*res = geom_to_geojson(geom, srs, precision, has_bbox)) == NULL )
+		throw(MAL, "geom.wkbAsGeoJson", "Failed, GeoJson returned is NULL!!!");
+	return MAL_SUCCEED;
+}
diff -r d3612c7f9d7b geom/monetdb5/geom.h
--- a/geom/monetdb5/geom.h	Tue Apr 12 01:30:53 2016 +0200
+++ b/geom/monetdb5/geom.h	Mon Apr 18 19:40:38 2016 +0200
@@ -226,6 +226,8 @@
 
 geom_export str wkbDump(bat* idBAT_id, bat* geomBAT_id, wkb**);
 geom_export str wkbDumpPoints(bat* idBAT_id, bat* geomBAT_id, wkb**);
+geom_export str wkbPolygonize(wkb **res, wkb **geom);
+geom_export str wkbSimplifyPreserveTopology(wkb **res, wkb **geom, float *tolerance);
 
 geom_export str geom_2_geom(wkb** resWKB, wkb **valueWKB, int* columnType, int* columnSRID); 
 
@@ -294,3 +296,28 @@
 
 geom_export int geom_catalog_upgrade(void *, int);
 geom_export str geom_sql_upgrade(int);
+
+/* To Export X3D and GeoJSON */
+#define OUT_MAX_DOUBLE_PRECISION 15
+#define OUT_MAX_DOUBLE 1E15
+#define OUT_SHOW_DIGS_DOUBLE 20
+#define OUT_MAX_DOUBLE_PRECISION 15
+#define OUT_MAX_DIGS_DOUBLE (OUT_SHOW_DIGS_DOUBLE + 2)
+#define GEOM_X3D_FLIP_XY         (1<<0)
+#define GEOM_X3D_USE_GEOCOORDS   (1<<1)
+#define X3D_USE_GEOCOORDS(x) ((x) & GEOM_X3D_USE_GEOCOORDS)
+
+
+typedef struct {
+    double xmin; 
+    double ymin; 
+    double zmin; 
+    double xmax; 
+    double ymax; 
+    double zmax; 
+} box3D;
+
+geom_export char *geom_to_geojson(GEOSGeom geom, char *srs, int precision, int has_bbox);
+geom_export char *geom_to_x3d_3(GEOSGeom geom, int precision, int opts, const char *defid);
+geom_export str wkbAsX3D(str *res, wkb **geom, int *maxDecDigits, int *options);
+geom_export str wkbAsGeoJson(str *res, wkb **geom, int *maxDecDigits, int *options);
diff -r d3612c7f9d7b geom/monetdb5/geom.mal
--- a/geom/monetdb5/geom.mal	Tue Apr 12 01:30:53 2016 +0200
+++ b/geom/monetdb5/geom.mal	Mon Apr 18 19:40:38 2016 +0200
@@ -334,6 +334,10 @@
 comment "Gets a MultiPolygon and returns the Polygons in it";
 command DumpPoints(a:wkb) (id:bat[:oid, :str], geom:bat[:oid, :wkb]) address wkbDumpPoints
 comment "Gets a Geometry and returns the Points in it";
+command Polygonize(a:wkb) :wkb address wkbPolygonize
+comment "Creates a GeometryCollection containing possible polygons formed from the constituent linework of a set of geometries.";
+command SimplifyPreserveTopology(a:wkb, t:flt) :wkb address wkbSimplifyPreserveTopology
+comment "Returns a \"simplified\" version of the given geometry using the Douglas-Peucker algorithm.";
 
 command Segmentize(g:wkb, sz:dbl) :wkb address wkbSegmentize
 comment "It creates a new geometry with all segments on it smaller or equal to sz";
@@ -512,6 +516,16 @@
 	return x;
 end YMaxFromMBR;
 
+#SFCGDAL functionality
+command Extrude(a:wkb, ex:dbl, ey:dbl, ez:dbl) :wkb address wkbExtrude
+comment "Extrude a surface to a related volume.";
+
+command StraightSkeleton(a:wkb) :wkb address wkbStraightSkeleton
+comment "Compute a straight skeleton from a geometry";
+
+command ST_Tesselate(a:wkb) :wkb address wkbTesselate
+comment "Perform surface Tesselation of a polygon or polyhedralsurface and returns as a TIN or collection of TINS.";
+
 
 #command mbr(:flt,:flt,:flt,:flt) :mbr
 #address ordinatesMBR
@@ -789,3 +803,10 @@
         x := geom.FromText(wkt,0,0);
         return x;
 end wkb;
+
+#Exported from PostGis
+command asX3D(geom:wkb, maxDecDigits:int, options:int) :str address wkbAsX3D;
+comment "Returns a Geometry in X3D xml node element format: ISO-IEC-19776-1.2-X3DEncodings-XML"
+
+command asGeoJson(geom:wkb, maxDecDigits:int, options:int) :str address wkbAsGeoJson;
+comment "Return the geometry as a GeoJSON element."
diff -r d3612c7f9d7b geom/monetdb5/sfcgal.c
--- a/geom/monetdb5/sfcgal.c	Tue Apr 12 01:30:53 2016 +0200
+++ b/geom/monetdb5/sfcgal.c	Mon Apr 18 19:40:38 2016 +0200
@@ -13,6 +13,15 @@
 
 #include "sfcgal.h"
 
+static sfcgal_geometry_t* geom_to_SFCGAL(str *ret, GEOSGeom geom, int type);
+static str geos2sfcgal(sfcgal_geometry_t **res, GEOSGeom geosGeometry);
+
+static void GEOSGeomGetZ(GEOSGeom geom, double *z) {
+    const GEOSCoordSequence* gcs_new;
+    gcs_new = GEOSGeom_getCoordSeq(geom);	
+    GEOSCoordSeq_getZ(gcs_new, 0, z);
+}
+
 char *
 geom_sfcgal_version(char **ret)
 {
@@ -20,3 +29,295 @@
 
 	return MAL_SUCCEED;
 }
+
+/* SFCGDAL functionality */
+str
+geom_sfcgal_extrude(wkb **res, wkb **geom, double *ex, double *ey, double *ez)
+{
+	sfcgal_geometry_t *outGeom, *inGeom;
+	GEOSGeom geosGeometry = wkb2geos(*geom);
+	size_t len;
+	char *buf; //[BUFSIZ];
+
+	if (geos2sfcgal(&inGeom, geosGeometry) != MAL_SUCCEED) {
+		*res = NULL;
+		return createException(MAL, "geom.Extrude", "GEOSExtrude failed");
+	}
+	if (!(outGeom = sfcgal_geometry_extrude (inGeom, *ex, *ey, *ez))) {
+		*res = NULL;
+		return createException(MAL, "geom.Extrude", "GEOSExtrude failed");
+	}
+
+	sfcgal_geometry_as_text(outGeom, &buf, &len);
+	*res = geos2wkb(GEOSGeomFromWKT(buf));
+	return MAL_SUCCEED;
+}
+
+str
+geom_sfcgal_straightSkeleton(wkb **res, wkb **geom)
+{
+	sfcgal_geometry_t *outGeom, *inGeom;
+	GEOSGeom geosGeometry = wkb2geos(*geom);
+	size_t len;
+	char *buf; //[BUFSIZ];
+
+	if (geos2sfcgal(&inGeom, geosGeometry) != MAL_SUCCEED) {
+		*res = NULL;
+		return createException(MAL, "geom.StraightSkeleton", "GEOSStraightSkeleton failed");
+	}
+	if (!(outGeom = sfcgal_geometry_straight_skeleton(inGeom))) {
+		*res = NULL;
+		return createException(MAL, "geom.StraightSkeleton", "GEOSStraightSkeleton failed");
+	}
+
+	sfcgal_geometry_as_text(outGeom, &buf, &len);
+	*res = geos2wkb(GEOSGeomFromWKT(buf));
+	return MAL_SUCCEED;
+}
+
+str
+geom_sfcgal_tesselate(wkb **res, wkb **geom)
+{
+	sfcgal_geometry_t *outGeom, *inGeom;
+	GEOSGeom geosGeometry = wkb2geos(*geom);
+	size_t len;
+	char *buf; //[BUFSIZ];
+
+	if (geos2sfcgal(&inGeom, geosGeometry) != MAL_SUCCEED) {
+		*res = NULL;
+		return createException(MAL, "geom.Tesselate", "GEOSTesselate failed");
+	}
+	if (!(outGeom = sfcgal_geometry_tesselate(inGeom))) {
+		*res = NULL;
+		return createException(MAL, "geom.Tesselate", "GEOSTesselate failed");
+	}
+
+	sfcgal_geometry_as_text(outGeom, &buf, &len);
+	*res = geos2wkb(GEOSGeomFromWKT(buf));
+	return MAL_SUCCEED;
+}
+
+static sfcgal_geometry_t *
+geom_to_SFCGAL(str *ret, GEOSGeom geom, int type)
+{
+    int is_3d;
+    double point_x = 0.0, point_y = 0.0, point_z = 0.0;
+    int i;
+    *ret = MAL_SUCCEED;
+
+    is_3d = GEOS_getWKBOutputDims(geom) == 3;
+
+    switch (type)
+    {
+        case wkbPoint_mdb:
+            {
+                GEOSGeomGetX(geom, &point_x);
+                GEOSGeomGetY(geom, &point_y);
+                if (is_3d) {
+                    GEOSGeomGetZ(geom, &point_z);
+                    return sfcgal_point_create_from_xyz(point_x, point_y, point_z);
+                } else
+                    return sfcgal_point_create_from_xy(point_x, point_y);
+            }
+            break;
+
+        case wkbLineString_mdb:
+            {
+                sfcgal_geometry_t* line = sfcgal_linestring_create();
+                int numPoints = GEOSGeomGetNumPoints(geom);
+                for (i = 0; i < numPoints; i++)
+                {
+                    GEOSGeom pointG = GEOSGeomGetPointN(geom, i);
+                    GEOSGeomGetX(pointG, &point_x);
+                    GEOSGeomGetY(pointG, &point_y);
+                    if (is_3d)
+                    {
+                        GEOSGeomGetZ(pointG, &point_z);
+                        sfcgal_linestring_add_point(line,
+                                sfcgal_point_create_from_xyz(point_x, point_y, point_z));
+                    }
+                    else
+                    {
+                        sfcgal_linestring_add_point(line,
+                                sfcgal_point_create_from_xy(point_x, point_y));
+                    }
+                }
+
+                return line;
+            }
+            break;
+
+        case wkbTriangle_mdb:
+            {
+                GEOSGeometry* pointG;
+                sfcgal_geometry_t* triangle = sfcgal_triangle_create();
+
+                pointG = GEOSGeomGetPointN(geom, 0);
+                GEOSGeomGetX(pointG, &point_x);
+                GEOSGeomGetY(pointG, &point_y);
+                if (is_3d){
+                    GEOSGeomGetZ(pointG, &point_z);
+                    sfcgal_triangle_set_vertex_from_xyz(triangle, 0, point_x, point_y, point_z);
+                } else
+                    sfcgal_triangle_set_vertex_from_xy (triangle, 0, point_x, point_y);
+
+                pointG = GEOSGeomGetPointN(geom, 1);
+                GEOSGeomGetX(pointG, &point_x);
+                GEOSGeomGetY(pointG, &point_y);
+                if (is_3d){
+                    GEOSGeomGetZ(pointG, &point_z);
+                    sfcgal_triangle_set_vertex_from_xyz(triangle, 1, point_x, point_y, point_z);
+                } else
+                    sfcgal_triangle_set_vertex_from_xy (triangle, 1, point_x, point_y);
+
+
+                pointG = GEOSGeomGetPointN(geom, 2);
+                GEOSGeomGetX(pointG, &point_x);
+                GEOSGeomGetY(pointG, &point_y);
+                if (is_3d){
+                    GEOSGeomGetZ(pointG, &point_z);
+                    sfcgal_triangle_set_vertex_from_xyz(triangle, 2, point_x, point_y, point_z);
+                } else
+                    sfcgal_triangle_set_vertex_from_xy (triangle, 2, point_x, point_y);
+
+                return triangle;
+            }
+            break;
+
+        default:
+            *ret = createException(MAL, "geom_to_sfcgal", "Unknown geometry type");
+            return NULL;
+    }
+}
+
+
+static str
+geos2sfcgal(sfcgal_geometry_t **res, GEOSGeom geosGeometry)
+{
+    int i, numGeometries = GEOSGetNumGeometries(geosGeometry);
+    int type = GEOSGeomTypeId(geosGeometry)+1;
+    sfcgal_geometry_t* ret_geom = NULL;
+    str ret = MAL_SUCCEED;
+
+    switch (type)
+    {
+        case wkbPoint_mdb:
+            {
+                if (GEOSisEmpty(geosGeometry) == 1) {
+                    *res = sfcgal_point_create();
+                    break;
+                }
+                *res = geom_to_SFCGAL(&ret, geosGeometry, wkbPoint_mdb);
+            }
+            break;
+
+        case wkbLineString_mdb:
+            {
+                if (GEOSisEmpty(geosGeometry) == 1) {
+                    *res = sfcgal_linestring_create();
+                    break;
+                }
+                *res = geom_to_SFCGAL(&ret, geosGeometry, wkbLineString_mdb);
+            }
+            break;
+
+        case wkbTriangle_mdb:
+            {
+                if (GEOSisEmpty(geosGeometry) == 1) {
+                    res = sfcgal_triangle_create();
+                    break;
+                }
+                *res = geom_to_SFCGAL(&ret, geosGeometry, wkbTriangle_mdb);
+            }
+            break;
+
+        case wkbPolygon_mdb:
+            {
+                int numInteriorRings = GEOSGetNumInteriorRings(geosGeometry);
+                sfcgal_geometry_t* exterior_ring;
+
+                if (GEOSisEmpty(geosGeometry) == 1) {
+                    *res = sfcgal_polygon_create();
+                    break;
+                }
+
+                exterior_ring = geom_to_SFCGAL(&ret, *(GEOSGeom*)GEOSGetExteriorRing(geosGeometry), wkbLineString_mdb);
+                ret_geom = sfcgal_polygon_create_from_exterior_ring(exterior_ring);
+
+                for (i = 0; i < numInteriorRings; i++)
+                {
+                    sfcgal_geometry_t* ring = geom_to_SFCGAL(&ret, *(GEOSGeom*)GEOSGetInteriorRingN(geosGeometry, i), wkbLineString_mdb);
+                    sfcgal_polygon_add_interior_ring(ret_geom, ring);
+                }
+                *res = ret_geom;
+            }
+            break;
+
+        case wkbMultiPoint_mdb:
+        case wkbMultiLineString_mdb:
+        case wkbMultiPolygon_mdb:
+        case wkbGeometryCollection_mdb:
+            {
+                if (type == wkbMultiPoint_mdb)
+                    ret_geom = sfcgal_multi_point_create();
+                else if (type == wkbMultiLineString_mdb)
+                    ret_geom = sfcgal_multi_linestring_create();
+                else if (type == wkbMultiPolygon_mdb)
+                    ret_geom = sfcgal_multi_polygon_create();
+                else
+                    ret_geom = sfcgal_geometry_collection_create();
+
+                for (i = 0; i < numGeometries; i++)
+                {
+                    sfcgal_geometry_t *g;
+                    ret = geos2sfcgal(&g, *(GEOSGeom*)GEOSGetGeometryN(geosGeometry, i));
+                    sfcgal_geometry_collection_add_geometry(ret_geom, g);
+                }
+                *res = ret_geom;
+            }
+            break;
+
+        case wkbPolyehdralSurface_mdb:
+            {
+                ret_geom = sfcgal_polyhedral_surface_create();
+                for (i = 0; i < numGeometries; i++)
+                {
+                    sfcgal_geometry_t* g;
+                    ret = geos2sfcgal(&g, *(GEOSGeom*)GEOSGetGeometryN(geosGeometry, i));
+                    sfcgal_polyhedral_surface_add_polygon(ret_geom, g);
+                }
+                /*
+                 * TODO: Fix this part
+                 if (FLAGS_GET_SOLID(lwp->flags))
+                 {
+                 *res = sfcgal_solid_create_from_exterior_shell(ret_geom);
+                 break;
+                 }
+                 */
+
+                *res = ret_geom;
+            }
+            break;
+
+        case wkbTin_mdb:
+            {
+                ret_geom = sfcgal_triangulated_surface_create();
+
+                for (i = 0; i < numGeometries; i++)
+                {
+                    sfcgal_geometry_t* g;
+                    ret = geos2sfcgal(&g, *(GEOSGeom*)(GEOSGetGeometryN(geosGeometry, i)));
+                    sfcgal_triangulated_surface_add_triangle(ret_geom, g);
+                }
+
+                *res = ret_geom;
+            }
+            break;
+
+        default:
+            ret = createException(MAL, "geom2cgal", "Unknown geometry type");
+            *res = NULL;
+    }
+
+    return ret;
+}
diff -r d3612c7f9d7b geom/monetdb5/sfcgal.h
--- a/geom/monetdb5/sfcgal.h	Tue Apr 12 01:30:53 2016 +0200
+++ b/geom/monetdb5/sfcgal.h	Mon Apr 18 19:40:38 2016 +0200
@@ -39,3 +39,7 @@
 #endif
 
 geom_export char * geom_sfcgal_version(char **ret);
+geom_export str geom_sfcgal_extrude(wkb **res, wkb **geom, double *ex, double *ey, double *ez);
+geom_export str geom_sfcgal_straightSkeleton(wkb **res, wkb **geom);
+geom_export str geom_sfcgal_tesselate(wkb **res, wkb **geom);
+
diff -r d3612c7f9d7b geom/monetdb5/sfcgal.mal
--- a/geom/monetdb5/sfcgal.mal	Tue Apr 12 01:30:53 2016 +0200
+++ b/geom/monetdb5/sfcgal.mal	Mon Apr 18 19:40:38 2016 +0200
@@ -9,3 +9,12 @@
 command version() :str address geom_sfcgal_version
 comment "Returns the version number of the SFCGAL library";
 
+command extrude(geo:wkb, x:dbl, y:dbl, z:dbl) : wkb address geom_sfcgal_extrude
+comment "Extrude a surface to a related volume"
+
+command straightSkeletion(geo:wkb) : wkb address geom_sfcgal_straightSkeleton
+comment "Compute a straight skeleton from a geometry"
+
+command tesselate(geo:wkb) : wkb address geom_sfcgal_tesselate
+commnet "Perform surface Tesselation of a polygon or polyhedralsurface and returns as a TIN or collection of TINS"
+
diff -r d3612c7f9d7b geom/sql/40_geom.sql
--- a/geom/sql/40_geom.sql	Tue Apr 12 01:30:53 2016 +0200
+++ b/geom/sql/40_geom.sql	Mon Apr 18 19:40:38 2016 +0200
@@ -4372,14 +4372,14 @@
 --CREATE FUNCTION ST_MakeValid RETURNS EXTERNAL NAME
 --CREATE FUNCTION ST_MemUnion RETURNS EXTERNAL NAME
 --CREATE FUNCTION ST_MinimumBoundingCircle RETURNS EXTERNAL NAME
---CREATE FUNCTION ST_Polygonize RETURNS EXTERNAL NAME
+CREATE FUNCTION ST_Polygonize(gemo1 Geometry) RETURNS Geometry EXTERNAL NAME geom."Polygonize";
 --CREATE FUNCTION ST_Node RETURNS EXTERNAL NAME
 --CREATE FUNCTION ST_OffsetCurve RETURNS EXTERNAL NAME
 --CREATE FUNCTION ST_RemoveRepeatedPoints RETURNS EXTERNAL NAME
 --CREATE FUNCTION ST_SharedPaths RETURNS EXTERNAL NAME
 --CREATE FUNCTION ST_Shift_Longitude RETURNS EXTERNAL NAME
 --CREATE FUNCTION ST_Simplify RETURNS EXTERNAL NAME
---CREATE FUNCTION ST_SimplifyPreserveTopology RETURNS EXTERNAL NAME
+CREATE FUNCTION ST_SimplifyPreserveTopology(geom1 Geometry, tolerance real) RETURNS Geometry EXTERNAL NAME geom."SimplifyPreserveTopology";
 --CREATE FUNCTION ST_Split RETURNS EXTERNAL NAME
 --CREATE FUNCTION ST_Union(geometry set geoms)?????
 --CREATE FUNCTION ST_UnaryUnion RETURNS EXTERNAL NAME
@@ -4456,3 +4456,5 @@
 ---------------------------- Miscellaneous ------------------------------
 -------------------------------------------------------------------------
 CREATE FUNCTION Contains(a Geometry, x double, y double) RETURNS BOOLEAN external name geom."Contains";
+CREATE FUNCTION ST_AsX3D(a Geometry, maxDecDigits int, options int) returns string external name geom."asX3D";
+CREATE FUNCTION ST_AsGeoJson(a Geometry, maxDecDigits int, options int) returns string external name geom."asGeoJson";
diff -r d3612c7f9d7b geom/sql/41_sfcgal.sql
--- a/geom/sql/41_sfcgal.sql	Tue Apr 12 01:30:53 2016 +0200
+++ b/geom/sql/41_sfcgal.sql	Mon Apr 18 19:40:38 2016 +0200
@@ -5,3 +5,7 @@
 -- Copyright 1997 - July 2008 CWI, August 2008 - 2016 MonetDB B.V.
 
 CREATE FUNCTION SFCGAL_VERSION() RETURNS string EXTERNAL NAME sfcgal."version";
+CREATE FUNCTION geometry ST_Extrude(geometry geom, double x, double y, double z) RETURNS geometry EXTERNAL NAME geom."extrude";
+CREATE FUNCTION geometry ST_StraightSkeleton(geometry geom) RETURNS geometry EXTERNAL NAME geom."straightSkeleton";
+CREATE FUNCTION geometry ST_Tesselate(geometry geom) RETURNS geometry EXTERNAL NAME geom."tesselate";
+--CREATE FUNCTION geometry ST_Triangulate2DZ(geometry geom) RETURNS geometry EXTERNAL NAME geom."Triangulate2DZ";;
